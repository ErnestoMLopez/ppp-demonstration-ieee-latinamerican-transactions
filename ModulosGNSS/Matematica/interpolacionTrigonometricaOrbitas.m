function [ps,vs] = interpolacionTrigonometricaOrbitas(t,tn,xn,yn,zn,w)
%INTERPOLACIONTRIGONOMETRICAORBITAS Interpolación trigonométrica de órbitas
% Obtiene las coordenadas de posición y velocidad de un satélite a partir de la
% interpolación trigonométrica de 9 puntos de datos de órbitas precisas.
%
% Dicha interpolación de 9 puntos, está dada por la siguiente expresión:
%	C = A0 + A1 sin(wt) + A2 cos(wt) + A3 sin(2wt) + A4 cos(2wt) +
%		A5 sin(3wt) + A6 cos(3wt) + A7 sin(4wt) + A8 cos(4wt)
%
% Donde w = 2*pi*1.00273781191135448 rad/día, y la constante es la
% relación entre un día solar y un día sidéreo.
% 
%
% ARGUMENTOS:
%	t			- Tiempo GPS para el que se quiere calcular la posición.
%	tn			- Épocas de los datos de órbitas precisas
%	xn			- Coordenadas X de posición en las épocas dadas
%	yn			- Coordenadas Y de posición en las épocas dadas
%	zn			- Coordenadas Z de posición en las épocas dadas
%	w			- Frecuencia angular para el polinomio interpolante
%
% DEVOLUCIÓN:
%	ps (3x1) -	Posición en el marco ECEF para el tiempo GPS dado [m]
%	vs (3x1) -	Velocidad en el marco ECEF para el tiempo GPS dado [m/s]

ps = NaN(3,1);
vs = NaN(3,1);

% Armo la matriz del sistema de ecuaciones
A =	[ones(9,1)...
	sin(w.*tn)...
	cos(w.*tn)...
	sin(2.*w.*tn)...
	cos(2.*w.*tn)...
	sin(3.*w.*tn)...
	cos(3.*w.*tn)...
	sin(4.*w.*tn)...
	cos(4.*w.*tn)];

% Resuelvo los 3 sistemas para hallar los 3 conjuntos de coeficientes
% del polinomio de interpolación
coef_x = A\xn;
coef_y = A\yn;
coef_z = A\zn;

% Cálculo las nuevas coordenadas de posición en el instante deseado
ps(1) =	coef_x(1) + ...
		coef_x(2).*sin(w.*t) + ...
		coef_x(3).*cos(w.*t) + ...
		coef_x(4).*sin(2.*w.*t) + ...
		coef_x(5).*cos(2.*w.*t) + ...
		coef_x(6).*sin(3.*w.*t) + ...
		coef_x(7).*cos(3.*w.*t) + ...
		coef_x(8).*sin(4.*w.*t) + ...
		coef_x(9).*cos(4.*w.*t);

ps(2) =	coef_y(1) + ...
		coef_y(2).*sin(w.*t) + ...
		coef_y(3).*cos(w.*t) + ...
		coef_y(4).*sin(2.*w.*t) + ...
		coef_y(5).*cos(2.*w.*t) + ...
		coef_y(6).*sin(3.*w.*t) + ...
		coef_y(7).*cos(3.*w.*t) + ...
		coef_y(8).*sin(4.*w.*t) + ...
		coef_y(9).*cos(4.*w.*t);

ps(3) =	coef_z(1) + ...
		coef_z(2).*sin(w.*t) + ...
		coef_z(3).*cos(w.*t) + ...
		coef_z(4).*sin(2.*w.*t) + ...
		coef_z(5).*cos(2.*w.*t) + ...
		coef_z(6).*sin(3.*w.*t) + ...
		coef_z(7).*cos(3.*w.*t) + ...
		coef_z(8).*sin(4.*w.*t) + ...
		coef_z(9).*cos(4.*w.*t);

% Cálculo las nuevas coordenadas de velocidad en el instante deseado
vs(1) =	w.*coef_x(2).*cos(w.*t) - ...
		w.*coef_x(3).*sin(w.*t) + ...
		2.*w.*coef_x(4).*cos(2.*w.*t) - ...
		2.*w.*coef_x(5).*sin(2.*w.*t) + ...
		3.*w.*coef_x(6).*cos(3.*w.*t) - ...
		3.*w.*coef_x(7).*sin(3.*w.*t) + ...
		4.*w.*coef_x(8).*cos(4.*w.*t) - ...
		4.*w.*coef_x(9).*sin(4.*w.*t);

vs(2) =	w.*coef_y(2).*cos(w.*t) - ...
		w.*coef_y(3).*sin(w.*t) + ...
		2.*w.*coef_y(4).*cos(2.*w.*t) - ...
		2.*w.*coef_y(5).*sin(2.*w.*t) + ...
		3.*w.*coef_y(6).*cos(3.*w.*t) - ...
		3.*w.*coef_y(7).*sin(3.*w.*t) + ...
		4.*w.*coef_y(8).*cos(4.*w.*t) - ...
		4.*w.*coef_y(9).*sin(4.*w.*t);

vs(3) =	w.*coef_z(2).*cos(w.*t) - ...
		w.*coef_z(3).*sin(w.*t) + ...
		2.*w.*coef_z(4).*cos(2.*w.*t) - ...
		2.*w.*coef_z(5).*sin(2.*w.*t) + ...
		3.*w.*coef_z(6).*cos(3.*w.*t) - ...
		3.*w.*coef_z(7).*sin(3.*w.*t) + ...
		4.*w.*coef_z(8).*cos(4.*w.*t) - ...
		4.*w.*coef_z(9).*sin(4.*w.*t);
	
end